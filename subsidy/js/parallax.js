// Generated by LiveScript 1.3.0
(function(){
  return ldc.register('parallax', [], function(){
    var lc, order, name, subsidy, total, maxtotal, root, box, x$, svg, ymap, hmap, isMobile, queue, flush, animate, cb, bezier, running, handle, start, rects, labels, texts, labelRects, ticks, i$, len$, j, y, tick, i, n, g, label, text, rect, rs, j$, len1$, r, setTick, setLabel, setLabelRect, setLabelText, setRect, update;
    lc = {};
    order = ['kmt', 'dpp', 'new', 'pfp', 'tsu', 'npp'];
    name = [['#3CB59A', '民進黨'], ['#467DB4', '國民黨'], ['#F0753F', '親民黨'], ['#B4865D', '台聯'], ['#FFDD1F', '新黨'], ['#FCBE2E', '時代力量']];
    subsidy = [
      {
        year: 1995,
        value: [15660780, 21745445, 6114655, 0, 0, 0]
      }, {
        year: 1996,
        value: [15563680, 25904145, 7129480, 0, 0, 0]
      }, {
        year: 1997,
        value: [156607800, 217454450, 61146550, 0, 0, 0]
      }, {
        year: 1998,
        value: [445025100, 698951850, 106269750, 0, 0, 0]
      }, {
        year: 2001,
        value: [517161000, 442405650, 0, 287675400, 120234000, 0]
      }, {
        year: 2004,
        value: [694285800, 638016200, 0, 270122600, 151342400, 0]
      }, {
        year: 2008,
        value: [722021200, 1002160200, 0, 0, 0, 0]
      }, {
        year: 2012,
        value: [911284800, 1172655800, 0, 144417800, 235759400, 0]
      }, {
        year: 2016,
        value: [1074190600, 656189800, 102014800, 158967600, 0, 148863000]
      }
    ];
    subsidy.map(function(it){
      var v, i, v2;
      v = 0;
      return it.sum = (function(){
        var i$, results$ = [];
        for (i$ = 0; i$ < 6; ++i$) {
          i = i$;
          v2 = v;
          v += it.value[i];
          results$.push(v2);
        }
        return results$;
      }());
    });
    total = name.map(function(d, i){
      return subsidy.map(function(it){
        return it.value[i];
      }).reduce(function(a, b){
        return a + b;
      }, 0);
    });
    maxtotal = Math.max.apply(null, total);
    root = ld$.find(document, '#parallax', 0);
    box = root.getBoundingClientRect();
    x$ = root.style;
    x$.width = box.width + "px";
    x$.height = box.height + "px";
    svg = ld$.find(root, 'svg', 0);
    ymap = function(it){
      return 400 - 250 * it / 2000000000;
    };
    hmap = function(it){
      return 250 * it / 2000000000;
    };
    isMobile = function(){
      return window.innerWidth < 768;
    };
    window.addEventListener('scroll', function(){
      var n1, n2, box2, box1, size, dp, percent;
      n1 = ld$.find(document, '#parallax-start', 0);
      n2 = ld$.find(document, '#parallax-end', 0);
      box2 = n2.getBoundingClientRect();
      box1 = n1.getBoundingClientRect();
      box2.y = box2.top;
      box1.y = box1.top;
      size = box2.y - box1.y;
      dp = isMobile() ? 10 : 0;
      percent = 100 * (size - box2.y) / size + dp;
      if (percent < 18 && lc.step !== 1) {
        return update(1, false);
      } else if (percent >= 18 && percent < 33 && lc.step !== 2) {
        return update(2, false);
      } else if (percent >= 33 && percent < 50 && lc.step !== 3) {
        return update(3, false);
      } else if (percent >= 50 && lc.step !== 4) {
        return update(4, false);
      }
    });
    queue = [];
    flush = function(){
      return queue.splice(0, queue.length);
    };
    animate = function(node, e, dur){
      var ref$, s, t, k, v;
      dur == null && (dur = 330);
      ref$ = [{}, {}], s = ref$[0], t = ref$[1];
      for (k in e) {
        v = e[k];
        s[k] = node.getAttribute(k);
        if (!isNaN(+s[k])) {
          ref$ = ['number', +s[k], +e[k]], t[k] = ref$[0], s[k] = ref$[1], e[k] = ref$[2];
        } else if (!isNaN(ldColor.hsl(s[k]).a)) {
          ref$ = ['color', ldColor.hsl(s[k]), ldColor.hsl(e[k])], t[k] = ref$[0], s[k] = ref$[1], e[k] = ref$[2];
        } else if (/\d+/.exec(s[k])) {
          ref$ = ['numstr', new NumStr(s[k]), new NumStr(e[k])], t[k] = ref$[0], s[k] = ref$[1], e[k] = ref$[2];
        } else {
          ref$ = ['string', s[k], e[k]], t[k] = ref$[0], s[k] = ref$[1], e[k] = ref$[2];
        }
      }
      node.ani = {
        s: s,
        e: e,
        t: t,
        dur: dur,
        st: 0
      };
      if (!in$(node, queue)) {
        return queue.push(node);
      }
    };
    cb = [0.75, 0, 0.25, 1];
    bezier = function(t){
      return cubic.Bezier.y(cubic.Bezier.t(t, cb), cb);
    };
    running = false;
    handle = function(time){
      running = true;
      queue.map(function(n){
        var ref$, s, e, t, st, dur, percent, k, v, ce, cs, ci, results$ = [];
        if (!n.ani.st) {
          n.ani.st = time;
        }
        ref$ = n.ani, s = ref$.s, e = ref$.e, t = ref$.t, st = ref$.st, dur = ref$.dur;
        n.ani.percent = percent = bezier((ref$ = (time - st) / dur) < 1 ? ref$ : 1);
        for (k in s) {
          v = s[k];
          if (t[k] === 'number') {
            v = (e[k] - s[k]) * percent + s[k];
          } else if (t[k] === 'numstr') {
            v = NumStr.interpolate(s[k], e[k], percent);
          } else if (t[k] === 'color') {
            ce = ldColor.hsl(e[k]);
            cs = ldColor.hsl(s[k]);
            ci = {};
            ['h', 's', 'l', 'a'].map(fn$);
            v = ldColor.web(ci);
          } else {
            v = e[k];
          }
          results$.push(n.setAttribute(k, v));
        }
        return results$;
        function fn$(k){
          return ci[k] = (ce[k] - cs[k]) * percent + cs[k];
        }
      });
      queue = queue.filter(function(it){
        return it.ani.percent < 1;
      });
      if (queue.length) {
        return requestAnimationFrame(handle);
      } else {
        return running = false;
      }
    };
    start = function(){
      if (!running) {
        requestAnimationFrame(handle);
      }
      return running = true;
    };
    rects = [];
    labels = [];
    texts = [];
    labelRects = [];
    ticks = [];
    for (i$ = 0, len$ = subsidy.length; i$ < len$; ++i$) {
      j = i$;
      y = subsidy[i$];
      svg.appendChild(tick = ld$.create({
        ns: 'svg',
        name: 'text',
        attr: {
          'class': 'tick'
        }
      }));
      ticks.push(tick);
    }
    for (i$ = 0, len$ = name.length; i$ < len$; ++i$) {
      i = i$;
      n = name[i$];
      svg.appendChild(g = ld$.create({
        ns: 'svg',
        name: 'g',
        attr: {
          'class': 'group'
        }
      }));
      g.appendChild(label = ld$.create({
        ns: 'svg',
        name: 'g'
      }));
      label.appendChild(text = ld$.create({
        ns: 'svg',
        name: 'text'
      }));
      label.appendChild(rect = ld$.create({
        ns: 'svg',
        name: 'rect'
      }));
      labelRects.push(rect);
      labels.push(label);
      texts.push(text);
      rects.push(rs = []);
      for (j$ = 0, len1$ = subsidy.length; j$ < len1$; ++j$) {
        j = j$;
        y = subsidy[j$];
        g.appendChild(r = ld$.create({
          ns: 'svg',
          name: 'rect',
          attr: {
            fill: n[0]
          }
        }));
        rs.push(r);
      }
    }
    setTick = function(arg$){
      var step, node, j, year, init, attr;
      step = arg$.step, node = arg$.node, j = arg$.j, year = arg$.year, init = arg$.init;
      node.textContent = year.year;
      attr = {
        "font-size": isMobile() ? 20 : 16,
        x: (j + 0.5) * 472 / 9 + 20,
        y: 420,
        "text-anchor": "middle"
      };
      if (step <= 2) {
        attr.opacity = 0;
      }
      if (step === 3) {
        attr.opacity = 1;
      }
      if (init) {
        return ld$.attr(node, attr);
      } else {
        return animate(node, attr);
      }
    };
    setLabel = function(arg$){
      var step, node, i, name, year, val, init, attr;
      step = arg$.step, node = arg$.node, i = arg$.i, name = arg$.name, year = arg$.year, val = arg$.val, init = arg$.init;
      attr = step === 1
        ? {
          transform: "translate(" + (i * 75 + 43 + 25) + ",281)"
        }
        : step === 2
          ? {
            transform: "translate(" + (i * 75 + 43 + 25) + ",410)"
          }
          : {
            transform: "translate(" + (i * 30 + 166) + ",450)"
          };
      if (init) {
        return ld$.attr(node, attr);
      } else {
        return animate(node, attr);
      }
    };
    setLabelRect = function(arg$){
      var step, node, i, name, year, val, init, attr;
      step = arg$.step, node = arg$.node, i = arg$.i, name = arg$.name, year = arg$.year, val = arg$.val, init = arg$.init;
      attr = {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        rx: 2,
        ry: 2,
        fill: name[0]
      };
      if (step >= 3) {
        import$(attr, {
          x: -8,
          y: -8,
          width: 16,
          height: 16
        });
      }
      if (init) {
        return ld$.attr(node, attr);
      } else {
        return animate(node, attr);
      }
    };
    setLabelText = function(arg$){
      var step, node, i, name, year, val, init, attr;
      step = arg$.step, node = arg$.node, i = arg$.i, name = arg$.name, year = arg$.year, val = arg$.val, init = arg$.init;
      if (step === 1) {
        node.textContent = name[1];
      } else {
        node.textContent = name[1].charAt(0);
      }
      attr = {
        "font-size": isMobile() ? 24 : 16,
        rotate: -90,
        dy: "0.5em",
        dx: "1.75em",
        transform: "rotate(90)"
      };
      if (init) {
        return ld$.attr(node, attr);
      } else {
        return animate(node, attr);
      }
    };
    setRect = function(arg$){
      var step, node, i, j, name, year, val, init, attr, ref$;
      step = arg$.step, node = arg$.node, i = arg$.i, j = arg$.j, name = arg$.name, year = arg$.year, val = arg$.val, init = arg$.init;
      attr = {};
      import$(attr, step === 1
        ? {
          rx: 10,
          ry: 10
        }
        : {
          rx: 0,
          ry: 0
        });
      import$(attr, {
        x: i * 75 + 43,
        y: 221,
        width: 50,
        height: 50,
        fill: name[0]
      });
      if (step === 2) {
        import$(attr, {
          y: 400 - val + (val / 9) * j,
          height: val / 9 + 1
        });
      }
      if (step >= 3) {
        import$(attr, {
          x: j * 472 / 9 + 20,
          width: 472 / 9 - 2,
          y: ymap(year.sum[i] + year.value[i]),
          height: (ref$ = hmap(year.value[i]) - 2) > 0 ? ref$ : 0
        });
      }
      if (step === 4) {
        import$(attr, {
          fill: i === 5 ? name[0] : '#ccc'
        });
      }
      if (init) {
        return ld$.attr(node, attr);
      } else {
        return animate(node, attr);
      }
    };
    update = function(step, init){
      var i$, ref$, len$, j, year, i, n, val, j$, ref1$, len1$;
      init == null && (init = false);
      svg.setAttribute('viewBox', isMobile() ? "-45 0 602 512" : "0 0 1024 512");
      lc.step = step;
      for (i$ = 0, len$ = (ref$ = subsidy).length; i$ < len$; ++i$) {
        j = i$;
        year = ref$[i$];
        setTick({
          step: step,
          node: ticks[j],
          year: year,
          j: j,
          init: init
        });
      }
      for (i$ = 0, len$ = (ref$ = name).length; i$ < len$; ++i$) {
        i = i$;
        n = ref$[i$];
        val = 350 * total[i] / maxtotal;
        setLabelText({
          step: step,
          node: texts[i],
          name: n,
          i: i,
          val: val,
          init: init
        });
        setLabelRect({
          step: step,
          node: labelRects[i],
          name: n,
          i: i,
          val: val,
          init: init
        });
        setLabel({
          step: step,
          node: labels[i],
          name: n,
          i: i,
          val: val,
          init: init
        });
        for (j$ = 0, len1$ = (ref1$ = subsidy).length; j$ < len1$; ++j$) {
          j = j$;
          year = ref1$[j$];
          setRect({
            step: step,
            node: rects[i][j],
            name: n,
            year: year,
            i: i,
            j: j,
            val: val,
            init: init
          });
        }
      }
      return start();
    };
    return update(1, true);
  });
})();
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}